---
layout: post
title: "Programmiernen lernen - wie es nicht geht"
date: 2025-04-30 07:59:01 +0200
category: coding
author: 
tags: [coding, learning]
description: "Programmieren lernen f√§llt mir schwer. Hier nun, was bei mir nicht funktionierte."
image:
  path: /assets/img/post-header/header-programmieren-lernen.jpg
  alt: Programmieren lernen
---

# Aufgeben war zu jeder Zeit eine valide Option

Ob ich heute Programmieren kann, h√§ngt stark von meiner Laune und dem Projekt ab, an dem ich gerade arbeite. Wenn alles l√§uft, wie geplant, dann bilde ich mir durchaus ein, ich w√ºsste, was ich da tue. Spukt der Compiler aber eine Fehlermeldung aus, die selbst nach stundenlanger Recherche nicht weggehen mag, dann bin ich fest davon √ºberzeugt, dass ich es einfach nicht kann.

Programmieren lernen, das trieb mich schon in jungen Jahren an. Ausschlaggebend war der EDV-Unterricht an meine Schule, in welchem wir vieles gelernt haben, nur nicht zu programmieren. Das war Motivation genug f√ºr mich, es wenigstens einmal selbst zu versuchen. 

Also fing ich an, es mir beizubringen. Auf diesem steinigen Weg habe ich viel gelernt. Vor allem habe ich feststellen k√∂nnen, was alles nicht bei mir funktioniert hat. Es gibt zahllose Artikel dar√ºber, wie man die ersten Schritte in die Welt der Programmierung machen kann. Mit diesem Artikel will ich eine Facette hinzuf√ºgen, die oftmals zu kurz kommt: Einfach mal zu versagen.

Das trifft vor allem dann zu, wenn man Programmieren nicht auf dem akademischen Wege lernt. Als kreativer Freigeist f√§llt es mir zudem schwer, mich in logische Konzepte einzuarbeiten. Dazu kommt, dass ich kein Mathematik-Ass bin. Beste Voraussetzungen, um Programmieren auf dem h√§rtesten nur denkbaren Weg zu lernen. 

Es folgen meine ganz pers√∂nlichen ‚ÄûLessons learned‚Äú. M√∂gen sie anderen ein wenig Leid ersparen.

## Wenn ich nur genug lese, lerne ich es schon

Ich bin mir sicher, dass es zum Thema ‚ÄûProgrammieren lernen‚Äú inzwischen mehr Literatur gibt, als Sandk√∂rner auf der Erde. Und das ist auch verst√§ndlich, denn schon viele Code-Abenteurer wollten sich ein Herz nehmen und es auf diesem Wege lernen. Da liegt also auch einiges an Geld auf der Stra√üe. 

Nachdem ich meine ersten Schritte in Basic, HTML und CSS unternommen hatte, habe ich mir, sehr spontan, ein Buch √ºber die Programmiersprache ‚ÄûC++‚Äú gekauft. Der Autor des Buches wollte die Erlebnisse aus seinem Urlaub in Australien nutzen, um den Menschen diese Sprache beizubringen. Das war eine durchaus witzige Idee. Also habe ich neben dem Verhalten von K√§ngurus gelernt, was Standardbibliotheken sind. Na ja, eigentlich hatte ich nur den Teil mit den K√§ngurus verstanden.

Um es kurz zu machen, die Lernkurve war mir dann doch ein paar Grad zu steil. Hatte ich es Anfangs noch hinbekommen, eine Variable zu deklarieren, viel mir Kapitel 2 auf die F√º√üe. Objektorientierte Programmierung ist ein zu gro√üer Brocken, wenn man gerade erst gelernt hatte, wie man CSS-Klassen anlegt. 

Das Buch hatte mich derma√üen demotiviert, dass ich vom Programmieren erst einmal die Finger lie√ü. Das laste ich aber nicht dem Autor an, denn ich wollte praktisch Bergsteigen lernen, indem ich den Mount Everest hochgehe. Nackt. 

> **Was ich gelernt habe:** Sich nur auf Literatur zu verlassen, kann schnell in die Hose gehen. Vor allem dann, wenn man noch gar nicht richtig wei√ü, was man lernen will und sich v√∂llig illusorische Ziele setzt.

## Auf jeden Fall Java, C, C++ und PHP w√§re auch nicht schlecht

Jeder, der mit dem Programmieren anfangen will, stellt sich am Anfang die Frage, welche Sprache man denn lernen sollte. Es gibt Listen mit den beliebtesten Sprachen der Welt. Dann gibt es gen√ºgend Ratgeber, die einem erkl√§ren, warum man ausgerechnet jetzt die Sprache X lernen muss. Garniert wird das mit Erfahrungsberichten, wie sich jemand Sprache Y beigebracht hat, nur um dann einen Top-Job bei Google zu landen. Also lernt man am besten alles?

Ich bin genau hieran gescheitert. Hatte ich mich Anfangs noch mit JavaScript begn√ºgt, hatte ich nebenher noch versucht, ‚Äûschnell mal‚Äú PHP zu lernen. Aber dann sagte mir irgendein Artikel im Internet, das PHP l√§ngst tot sei, also schnell weiter zu ... Python! Das ist die Sprache der Zukunft, weil Machine Learning und Data Science und so. 

Dann musste ich mich aber an ein kleines Projekt setzen, dass meine JavaScript Skills verlangte. Mein Problem war jedoch, ich hatte keine. Ich hatte  diese Sprache nie wirklich verinnerlicht. Klar, ich konnte eine Variable deklarieren und Funktionen schreiben. Aber als es darum ging, mit dem [DOM](https://de.wikipedia.org/wiki/Document_Object_Model) zu interagieren, fing ich praktisch von vorne an zu lernen. 

Das Projekt was fertig, also hoppelte ich weiter, zur√ºck zu Python. Oje, auch hier wieder das Meiste vergessen. Das m√ºndete in Fehlermeldungen googeln und Doku w√§lzen bis die Sonne untergeht.

> **Was ich gelernt habe:** Ich h√§tte mich f√ºr den Anfang auf eine Sprache fokussieren sollen. Dann h√§tte ich nicht nur die Basis-Syntax gelernt, sondern auch, wie es sich mit dem √ñkosystem um eine solche Sprache verh√§lt. Vieles, was ich von einer Programmiersprache lerne, kann ich auf eine andere Sprache transferieren. So h√§tte ich viel effizienter lernen k√∂nnen.

## Der Online-Kurs macht mich zum Programmierer

Ich wollte so sehr Programmieren lernen, dass ich auch bereit war, viel Geld auszugeben. Klar, das Internet ist voll von kostenlosen Tutorials, Guides und Anleitungen. Qualit√§t gibt es aber nur gegen Bares. Oder? Ich war auch bereit, das auszugeben. Waren es am Anfang nur B√ºcher und kostenlose Kurse, habe ich mich sp√§ter dazu entschlossen, die Pro Membership auf [Codecademy](https://www.codecademy.com/) abzuschlie√üen. Die Kurse sind dann ich nur viel tiefgehender, es winkt am Ende auch ein Zertifikat. Yeah!

Also habe ich Kapitel f√ºr Kapitel abgearbeitet. HTML, CSS, JavaScript und wow, es kamen noch [Lodash](https://lodash.com/), [React](https://react.dev/), [REST-API](https://de.wikipedia.org/wiki/Representational_State_Transfer), Datenbanken, SQL usw. usf. dazu. Ich hielt am Ende mein Zertifikat in den digitalen H√§nden und durfte mich am Ende ‚ÄûFullstack Developer‚Äú nennen. Das Problem war nur, dass ich meine Euros los war, und immer noch nicht viel verstanden habe.

Ich habe einiges an Geld f√ºr einige Kurse ausgegeben. Nur hat mir der Wissensstrom nicht viel gebracht, da zu wenig backen blieb.

> **Was ich gelernt habe:** Online-Kurse k√∂nnen eine gro√üe Hilfe sein, bestimmte Themen zu verinnerlichen. Aber jeder Mensch lernt anders, ich halt auch. Sobald ich ein Kapitel abgeschlossen hatte, war mein Motto: *Aus den Augen, aus dem Sinn, auf zum n√§chsten Thema*. Da ich l√§nger brauche, ein Thema zu verstehen, sollte ich mich auf bestimmte Themen konzentrieren. Topic Jumping, wie es viele Online-Kurse tun, hat mich nicht weiter gebracht. 

## Das 3 Stunden 21 Minuten YouTube-Tutorial wird es bringen

Ich fand **React** immer spannend. Mein Problem war, dass ich es nie richtig verstanden habe. Wenn ich es geschafft habe, eine [Component](https://react.dev/reference/react/Component) zu erstellen und anzeigen zu lassen, hatte ich keinen blassen Schimmer, was da eigentlich vor sich ging. [Props?](https://react.dev/reference/react/Component#props), tolle Sache, aber h√§?

Also habe ich mir ein YouTube-Tutorial nach dem anderen gegeben. Ich bin den vielen Menschen auch dankbar, die diese erstellen. Ich habe mich voller Motivation hingesetzt und flei√üig alles abgeschrieben, was auf dem Bildschirm passierte. Nach 5 Stunden sa√ü ich mit meinem Instagram-Klon da und freute mich ... nicht. Denn auch hier musste ich feststellen, dass ich die verschiedenen Themen nicht richtig verstanden habe. Im Gegenteil, es frustrierte mich. Immer wieder musste ich Fehlermeldungen googeln, die nur bei mir auftraten. So habe ich zumindest das Thema ‚ÄûError Handling‚Äú gleich mit abgefr√ºhst√ºckt. Yay :(

Dazu kamen die vielen Tutorials, die einfach veraltet waren, was ich aber auf meine Kappe nehme. Denn wenn ich **React** eh nicht richtig verstanden habe, kann ich auch nicht einsch√§tzen, wenn das Tutorial mit hoffnungslos veralteten [NPM-Paketen](https://www.npmjs.com/) hantierte. Dann stellt man nach 2 Stunden Tutorial fest, dass es nicht weitergeht, weil das ‚Äûnpm package X‚Äú gar nicht mit der ‚ÄûVersion Y‚Äú von dem anderen Paket funktioniert. 

> **Was ich gelernt habe:** Stumpf Code vom Bildschirm abtippen hat mir nichts gebracht. Fehlen die Basics, dann gibt es bei mir auch kaum Lernfortschritt, egal wie viele Twitter- und Instagram-Klone man programmiert. Und ich sitze auf einem Berg davon. H√§tte ich **JavaScript** von Anfang an richtig gelernt, w√§re mir **React** nicht so schwergefallen. 

## Wenn ich das Zertifikat habe, bin ich Programmierer

Die allermeisten Kurse, ob off- oder online, werben mit Zertifikaten. Diese stehen dann am Ende eines oft steinigen Weges und versichern: ‚ÄûDu kannst das!‚Äú. 

Wenn es nach z.B. [Codecademy](https://www.codecademy.com/) geht, bin ich ‚ÄûWeb Developer‚Äú, ‚ÄûFullstack Developer‚Äú und ‚ÄûData Scientist‚Äú. Ich habe ja digitale Zertifikate, die mir genau das best√§tigen. Das Problem f√ºr mich ist jedoch, dass es einfach nicht stimmt. Ich habe mich brav durch die Kurse geklickt und gearbeitet, aber sehr wenig daraus mitgenommen. 

Dennoch m√∂chte ich Zertifikate nicht verteufeln. Ich habe auch Kurse gemacht, die mir etwas gebracht haben. Ich hatte mir einmal fest vorgenommen, Python zu lernen. Also dieses Mal richtig. Ich wollte nicht nur etwas programmieren, sondern auch verstehen, was da genau passierte. Was macht der Compiler, wie werden Variablen im Speicher angelegt, warum verh√§lt sich Python gerade so, wie es das tut. Am Ende winkte mir ebenfalls ein [Zertifikat](https://verify.openedg.org/?id=9dMG.6Ywi.Rt0o). Dieses Mal sah ich es aber als Best√§tigung daf√ºr, dass ich lernen und verstehen wollte. Das Wissen aus diesem Kurs hat mich weiter gebracht und ich konnte es auf andere Sprachen transferieren.

> **Was ich gelernt habe:** Zertifikate sind in einer idealen Welt F√§higkeitsnachweise. Viel zu oft sind sie aber eine Belohnung daf√ºr, dass man sich tapfer durch einen Online-Kurs geklickt hat. 

## Wenn ich die noch die Objektorientierung verstanden habe, bin ich fertig

Als ich damit begann, Programmieren zu lernen, habe ich mich der Illusion hingegeben, dass man irgendwann ‚Äûfertig‚Äú ist. Hatte ich mich durch den letzten Abschnitt im Kurs geklickt, oder das letzte Kapitel im Buch durchgearbeitet, dachte ich: ‚ÄûAlles klar, ich kann das nun‚Äú. Konnte ich das Wissen zudem auch transferieren und in einem funktionierenden Projekt manifestieren, verfestigte sich dieser Glaube noch.

Das Problem ist nur, nichts ist weiter von der Wahrheit entfernt. 

Ein gutes Beispiel ist wieder einmal **React**. In meinem Online-Kurs wurden mir brav die Unterschiede zwischen [*Class- und Functional-Components*](https://www.geeksforgeeks.org/differences-between-functional-components-and-class-components/) beigebracht. M√ºhsam hatte ich mir das Wissen angeeignet, nur um etwas sp√§ter festzustellen, dass [Hooks](https://react.dev/reference/react/hooks) der neue hei√üe Schei√ü ist. √ñkosysteme k√∂nnen sich schnell √§ndern. Der Sprung von Python 2 auf Python 3 war durchaus gewaltig. JavaScript mutiert, als w√ºrde es neben einem Atomreaktor wohnen und wenn man [Rust](https://www.rust-lang.org/), [Wasm](https://de.wikipedia.org/wiki/WebAssembly), [Flutter](https://flutter.dev/), oder was auch immer lernen will, dann sieht die Welt beim Aufstehen h√§ufig anders aus, als beim Zubettgehen.

Wenn man, wie ich, ohnehin schon Schwierigkeiten hat, den Fokus zu behalten und gerne auf mehreren Hochzeiten tanzen will, verliert schnell den Anschluss. Programmiersprachen sind keine statischen Gebilde, sondern √ñkosysteme, die sich st√§ndig weiterentwickeln. Syntax, Dokumentation, Bibliotheken, Module ... alles das, was eine Programmiersprache ausmacht, entwickelt sich st√§ndig weiter. Wenn man da nicht dran bleibt, verliert man schnell den Anschluss.

> **Was ich gelernt habe:** Ich werde nie fertig sein. Die Welt der Programmierung entwickelt sich st√§ndig weiter und das muss ich dann eben auch. Gl√ºck hat, wer in solchen Dingen dann flexibel ist. Mithalten kann, wer dran bleibt. Und Dank den AI-Chats dieser Welt,ist das auch gar nicht mehr so m√ºhsam.

## Mein Fazit

Ich habe eine steinige Reise hinter mir. Da ich mir das Programmieren selbst beibringen wollte und keine echte Orientierung hatte, war dies wie ein Spaziergang auf einem zugefrorenen See im Nebel und das bei Nacht. Ich habe viel probiert, oft aufgegeben, war oft verzweifelt. Und doch ...

Jedes Mal, wenn ich ein Kapitel gelesen hatte, einen Kurs gemacht habe oder einen ‚ÄûYelp-Klon‚Äú abgetippt habe, ist irgendwas h√§ngen geblieben. Hatte ich ein Thema nicht sofort verstanden, so hat es mir dennoch beim n√§chsten Versuch weiter geholfen. Als ich mich intensiver mit JavaScript besch√§ftigt hatte, wurden die **React** Windungen in meinem Hirn neu verkn√ºpft. Auf einmal hatte ich viele ‚ÄûAha‚Äú Erlebnisse. Also ich Python lernte hatte ich verstanden, warum ich z.B. mit C++ so grandios gescheitert war. 

Meine ‚ÄûPerlen der Weisheit‚Äú lauten wie folgt:

+ **HTML und CSS sind ein guter Anfang**: Ja, ja, ich wei√ü. Es handelt sich nicht um Programmiersprachen. F√§ngt man aber damit an, lernt man auf relativ bequeme Art die Basics: Was ist Code und wie / womit schreibe ich sowas, was ist Formatierung, was ist Syntax. Mit **CSS** kann man den kleinen Zeh sogar in das kalte Wasser der [Variablen](https://www.w3schools.com/css/css3_variables.asp) tunken. Ein guter Anfang und man erreicht schnell und mit wenig Aufwand die ersten Erfolge.

+ **JavaScript**: ist ein guter, zweiter Schritt. Ja, ja, ich wei√ü. Eigentlich auch keine richtige ... lassen wir das. Es geht ums Lernen und da ist **JavaScript** wirklich toll f√ºr. Erstens: Es baut auf **HTML** und **CSS** auf. Man kann seine ersten Projekte prima mit **JavaScript** erg√§nzen. Zweitens: Man lernt wichtige Konzepte kennen wie Funktionen, Schleifen, Variablen, Scope usw. Auch kann man seinen Zeh in das kalte Wasser der [Objektorientierung](https://wiki.selfhtml.org/wiki/JavaScript/Tutorials/OOP) tunken. 

+ **Python ist ein guter dritter Schritt**: Das ist aber nur eine Empfehlung meinerseits. **Python** hat mir viel Spa√ü gemacht. Ich hatte dazu einen Kurs mit Pr√§senzunterricht mit einem tollen Lehrer. Die Sprache ist meiner pers√∂nlichen Meinung nach gutm√ºtig zu Anf√§ngern und sehr intuitiv. Und da sie sich verh√§ltnism√§√üig schnell lernen l√§sst, lassen sich auch ruckzuck der ersten Erfolge erzielen. **Python** wird nachgesagt, dass es l√§ngst nicht so performant ist, wie andere Sprachen. Das mag aktuell noch stimmen. Aber es hat sich bei all den Data Scientists dieser Welt auch deswegen durchgesetzt, weil es so einfach lernen und anwenden l√§sst. Compiler? Was ist das? Mir reicht ein [Jupyter Notebook ](https://jupyter.org/) oder [Marimo](https://markus-daams.com/posts/python-notebook-mit-marimo/) und ich lege etwas [NLP](https://realpython.com/nltk-nlp-python/) auf das Parkett.  

+ **Es ist egal, was gerade beliebt ist**: Es hat mir nichts gebracht, mich auf beliebte Programmiersprachen zu konzentrieren. Wichtig ist, dass ich mich auf das konzentriere, was mir hilft, zu ein bestimmtes Thema zu verstehen. Ich habe mich mit [OOP](https://de.wikipedia.org/wiki/Objektorientierte_Programmierung) am Anfang sehr, sehr schwergetan. Mein Java Abenteuer war dann auch relativ schnell zu Ende und erst viel sp√§ter, hatte es mit **C#** dann Klick gemacht. 

+ **Selbst ist der Coder**: Nachdem ich meinen ungef√§hr dritten Instagram-Klon aus einem YouTube-Video abgetippt hatte, und immer noch nichts verstand, habe ich die Methode ge√§ndert. Ich habe mir selbst kleine Aufgaben gestellt. Zum Beispiel eine kleine Todo-Liste zu programmieren. Erst mit **JavaScript**, dann mit **React**. Als das geklappt hatte, wollte ich die Liste in einer SQL-Datenbank speichern. Vielleicht mit Registrierung? Uh, [Firebase](https://firebase.google.com/docs/auth/). Ich habe mir eine kleine Aufgabe gesetzt, sie selbst gel√∂st und dann die H√ºrde etwas h√∂her gelegt. Die ‚ÄûAha‚Äú Momente wurden mehr, ich hatte mehr Spa√ü und ich lernte mehr. Geholfen hatte mir, und das gebe ich gerne zu, auch das Wissen, aus all den Tutorials. Denn es blieb immer was h√§ngen.

+ **Zertifikate sind gut, aber nicht alles**: Ich hatte mein Profil auf LinkedIn mit all den Zertifikaten zu gekleistert, die ich mit der Zeit so angesammelt hatte. Allerdings hatte ich dennoch nie das Gef√ºhl, dass ich nun ein ‚ÄûProgrammierer‚Äú bin. Inzwischen habe ich einen anderen Blick darauf. Die Zertifikate zeigen, dass ich bereit bin, viel Zeit, M√ºhe und manchmal auch Geld in eine Sache zu investieren. Sie sind ein Nachweis meiner inneren Haltung und Einstellung. Es viel mir immer schwer und tut es noch, Programmieren zu lernen. Aber ich kann nachweisen, dass ich nie aufgegeben habe. Naja, nur manchmal.

#### Der wichtigste Tipp zum Schluss

+ **Niemals aufgeben**: Ich habe immer wieder die Flinte ins Korn geworfen. Eine Fehlermeldung, die nicht wegging, oder die [Klassen-Methode](https://www.geeksforgeeks.org/classmethod-in-python/), die einfach nicht wollte, wie ich. Programmieren lernen hei√üt leiden lernen und lauthals zu fluchen. Wer keine Fehler macht, hat sowieso nichts verstanden. Erst, als ich mich auf eine Sprache und ein Projekt konzentriert habe, habe ich auch gelernt, wie man mit den Fehlern der Sprache und mit den eigenen umgehen muss. Irgendwann hatte ich mich sogar dabei erwischt, mich √ºber den einen oder anderen Fehler zu freuen, denn es war eine Gelegenheit, noch etwas tiefer in die Untiefen der Sprache abzutauchen. Also, Code Editor noch mal √∂ffnen und schaue, ob man es nicht doch irgendwie hinkriegt.

Es war f√ºr mich ein steiniger Weg, programmieren zu lernen. Ob ich es wirklich kann, daran zweifele ich nach wie vor. Aber ich bin inzwischen davon √ºberzeugt, dass genau diese Zweifel dazu geh√∂ren. Ich habe w√§hrend dieser Reise viel √ºber mich gelernt und wie ich mit Problemen und Fehlern umgehe. Wichtiger ist aber, dass ich jedes Mal *dazugelernt* habe. Bei allem, was ich tat, blieb immer ein kleiner Fetzen Wissen kleben und mit der Zeit, erschlossen sich mir immer mehr Zusammenh√§nge. Diese Wissenstransfers haben die Sache so interessant f√ºr mich gemacht. 

Wer auch immer das Abenteuer ‚Äûprogrammieren lernen‚Äú starten m√∂chte, dem w√ºnsche ich viel Mut, Kraft und Durchhaltewillen. Scheitern ist ein Zeichen daf√ºr, dass es einen besseren Weg gibt.

Ich selbst stelle mich nun einer neuen Herausforderung: Ich programmiere mir eine [API](https://www.rustfinity.com/blog/create-high-performance-rest-api-with-rust) f√ºr meine **React** App mit [Rust](https://rust-lang-de.github.io/rustbook-de/title-page.html). Was soll da schon schiefgehen k√∂nnen üòè?